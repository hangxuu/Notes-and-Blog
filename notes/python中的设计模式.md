设计模式是语言相关的。

具体模式的实现语言相关，但六大原则是通用的。
1. 单一职责原则：一个类只负责一项职责。
2. 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。
3. 依赖倒置原则：面向接口编程，而不要面向实现编程。
4. 接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
5. 迪米特法则（最少知道原则）：尽量降低类与类之间的耦合。
6. 开闭原则：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

## 创建型模式
创建型模式处理对象实例化机制。
### 单例模式
定义：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例。

单例模式有三个特点：
1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点；

通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。

### 工厂模式
定义一个用于创建产品的接口，由子类决定生产什么产品。

优点：
- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

缺点：
- 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。


## 结构型模式

### 适配器模式
### 代理模式
### 外观模式

## 行为模式
行为模式旨在通过结构化它们的交互过程来简化类之间的交互。
### 策略模式
定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变化。经常用京东买东西会发现：京东里每件商品一般都有不同的促销策略。比如：
- 99元选4件
- 满2件总价打9折
- 满3件总价打8折

策略模式涉及以下内容：
- 上下文：调用不同策略的主体。
- 策略：实现不同算法的组件共同的接口。
- 具体策略：具体算法的实现。

实现上述京东中三种不同促销策略，以及选择最佳策略见代码 [jd_strategy.py](https://github.com/hangxuu/Notes-and-Blog/tree/master/codes/design_pattern/jd_strategy.py)。

### 命令模式
命令模式的目的是解耦调用操作的对象（调用者）和提供实现的对象（接收者）。这个模式的做法是：在调用者和接收者之间放一个``command``对象，让它实现只有一个方法（execute）的接口，调用接收者中的方法执行所需的操作。这样，调用者无需了解接收者的接口，而且不同的接收者可以适应不同的``command``子类。

命令模式涉及以下内容：
- 抽象命令类：声明执行命令的接口。
- 具体命令类：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。
- 调用者：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。
- 接收者：执行命令功能的相关操作，是具体命令的真正实现者。

### 观察者模式
定义：指多个对象间存在一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式。

优点：
- 降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。
- 目标与观察者之间建立了一套触发机制。

### 访问者模式
- 访问者模式帮助分离算法和数据结构。并具有与观察者模式类似的目标。
- 如果你的应用程序具有由多个算法访问的数据结构，则访问者模式将有助于分离关注点。对于数据容器来说，最好只关注于提供数据访问和持有数据，而无需关心其它任何事情。

### 模板模式
- 模板通过定义抽象步骤来帮助设计一个通用算法。这些抽象步骤由子类/外部函数来实现。
- 对于可以变化并且可以被表示为独立的子步骤的算法，应当考虑模板。
- python内置的``sorted``函数，可以接受``key``参数，这就是把函数的部分实现委托给了外部实现的参数。``min``和``max``也是如此。


## 参考资料
- [设计模式六大原则](http://www.uml.org.cn/sjms/201211023.asp)
